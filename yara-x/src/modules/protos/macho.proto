syntax = "proto2";

import "yara.proto";

option (yara.module_options) = {
  name : "macho"
  root_message: "Macho"
  rust_module: "macho"
};

message Section {
  optional string segname = 1;
  optional string sectname = 2;
  optional uint64 addr = 3;
  optional uint64 size = 4;
  optional uint32 offset = 5;
  optional uint32 align = 6;
  optional uint32 reloff = 7;
  optional uint32 nreloc = 8;
  optional uint32 flags = 9;
  optional uint32 reserved1 = 10;
  optional uint32 reserved2 = 11;
  optional uint32 reserved3 = 12;
}

message Segment {
  optional uint32 cmd = 1;
  optional uint32 cmdsize = 2;
  optional string segname = 3;
  optional uint64 vmaddr = 4;
  optional uint64 vmsize = 5;
  optional uint64 fileoff = 6;
  optional uint64 filesize = 7;
  optional uint32 maxprot = 8;
  optional uint32 initprot = 9;
  optional uint32 nsects = 10;
  optional uint32 flags = 11;
  repeated Section sections = 12;
}

message Macho {
  // Set Mach-O header and basic fields
  optional uint32 magic = 1;
  optional uint32 cputype = 2;
  optional uint32 cpusubtype = 3;
  optional uint32 filetype = 4;
  optional uint32 ncmds = 5;
  optional uint32 sizeofcmds = 6;
  optional uint32 flags = 7;
  optional uint32 reserved = 8;
  optional uint64 number_of_segments = 9;
  repeated Segment segments = 10;
  optional uint64 entry_point = 11;
  optional uint64 stack_size = 12;

  // Set Mach-O definitions
  optional uint32 MH_MAGIC = 13;
  optional uint32 MH_CIGAM = 14;
  optional uint32 MH_MAGIC_64 = 15;
  optional uint32 MH_CIGAM_64 = 16;

  // Set FAT Mach-O definitions
  optional uint32 FAT_MAGIC = 17;
  optional uint32 FAT_CIGAM = 18;
  optional uint32 FAT_MAGIC_64 = 19;
  optional uint32 FAT_CIGAM_64 = 20;

  // Set 64bit masks
  optional uint32 CPU_ARCH_ABI64 = 21;
  optional uint32 CPU_SUBTYPE_LIB64 = 22;

  // Set CPU types
  optional uint32 CPU_TYPE_MC680X0 = 23;
  optional uint32 CPU_TYPE_X86 = 24;
  optional uint32 CPU_TYPE_I386 = 25;
  optional uint32 CPU_TYPE_X86_64 = 26;
  optional uint32 CPU_TYPE_MIPS = 27;
  optional uint32 CPU_TYPE_MC98000 = 28;
  optional uint32 CPU_TYPE_ARM = 29;
  optional uint32 CPU_TYPE_ARM64 = 30;
  optional uint32 CPU_TYPE_MC88000 = 31;
  optional uint32 CPU_TYPE_SPARC = 32;
  optional uint32 CPU_TYPE_POWERPC = 33;
  optional uint32 CPU_TYPE_POWERPC64 = 34;

  // Set CPU subtypes
  optional uint32 CPU_SUBTYPE_INTEL_MODEL_ALL = 35;
  optional uint32 CPU_SUBTYPE_386 = 36;
  optional uint32 CPU_SUBTYPE_I386_ALL = 37;
  optional uint32 CPU_SUBTYPE_X86_64_ALL = 38;
  optional uint32 CPU_SUBTYPE_486 = 39;
  optional uint32 CPU_SUBTYPE_486SX = 40;
  optional uint32 CPU_SUBTYPE_586 = 41;
  optional uint32 CPU_SUBTYPE_PENT = 42;
  optional uint32 CPU_SUBTYPE_PENTPRO = 43;
  optional uint32 CPU_SUBTYPE_PENTII_M3 = 44;
  optional uint32 CPU_SUBTYPE_PENTII_M5 = 45;
  optional uint32 CPU_SUBTYPE_CELERON = 46;
  optional uint32 CPU_SUBTYPE_CELERON_MOBILE = 47;
  optional uint32 CPU_SUBTYPE_PENTIUM_3 = 48;
  optional uint32 CPU_SUBTYPE_PENTIUM_3_M = 49;
  optional uint32 CPU_SUBTYPE_PENTIUM_3_XEON = 50;
  optional uint32 CPU_SUBTYPE_PENTIUM_M = 51;
  optional uint32 CPU_SUBTYPE_PENTIUM_4 = 52;
  optional uint32 CPU_SUBTYPE_PENTIUM_4_M = 53;
  optional uint32 CPU_SUBTYPE_ITANIUM = 54;
  optional uint32 CPU_SUBTYPE_ITANIUM_2 = 55;
  optional uint32 CPU_SUBTYPE_XEON = 56;
  optional uint32 CPU_SUBTYPE_XEON_MP = 57;
  optional uint32 CPU_SUBTYPE_ARM_ALL = 58;
  optional uint32 CPU_SUBTYPE_ARM_V4T = 59;
  optional uint32 CPU_SUBTYPE_ARM_V6 = 60;
  optional uint32 CPU_SUBTYPE_ARM_V5 = 61;
  optional uint32 CPU_SUBTYPE_ARM_V5TEJ = 62;
  optional uint32 CPU_SUBTYPE_ARM_XSCALE = 63;
  optional uint32 CPU_SUBTYPE_ARM_V7 = 64;
  optional uint32 CPU_SUBTYPE_ARM_V7F = 65;
  optional uint32 CPU_SUBTYPE_ARM_V7S = 66;
  optional uint32 CPU_SUBTYPE_ARM_V7K = 67;
  optional uint32 CPU_SUBTYPE_ARM_V6M = 68;
  optional uint32 CPU_SUBTYPE_ARM_V7M = 69;
  optional uint32 CPU_SUBTYPE_ARM_V7EM = 70;
  optional uint32 CPU_SUBTYPE_ARM64_ALL = 71;
  optional uint32 CPU_SUBTYPE_SPARC_ALL = 72;
  optional uint32 CPU_SUBTYPE_POWERPC_ALL = 73;
  optional uint32 CPU_SUBTYPE_MC980000_ALL = 74;
  optional uint32 CPU_SUBTYPE_POWERPC_601 = 75;
  optional uint32 CPU_SUBTYPE_MC98601 = 76;
  optional uint32 CPU_SUBTYPE_POWERPC_602 = 77;
  optional uint32 CPU_SUBTYPE_POWERPC_603 = 78;
  optional uint32 CPU_SUBTYPE_POWERPC_603E = 79;
  optional uint32 CPU_SUBTYPE_POWERPC_603EV = 80;
  optional uint32 CPU_SUBTYPE_POWERPC_604 = 81;
  optional uint32 CPU_SUBTYPE_POWERPC_604E = 82;
  optional uint32 CPU_SUBTYPE_POWERPC_620 = 83;
  optional uint32 CPU_SUBTYPE_POWERPC_750 = 84;
  optional uint32 CPU_SUBTYPE_POWERPC_7400 = 85;
  optional uint32 CPU_SUBTYPE_POWERPC_7450 = 86;
  optional uint32 CPU_SUBTYPE_POWERPC_970 = 87;

  // Set file types
  optional uint32 MH_OBJECT = 88;
  optional uint32 MH_EXECUTE = 89;
  optional uint32 MH_FVMLIB = 90;
  optional uint32 MH_CORE = 91;
  optional uint32 MH_PRELOAD = 92;
  optional uint32 MH_DYLIB = 93;
  optional uint32 MH_DYLINKER = 94;
  optional uint32 MH_BUNDLE = 95;
  optional uint32 MH_DYLIB_STUB = 96;
  optional uint32 MH_DSYM = 97;
  optional uint32 MH_KEXT_BUNDLE = 98;

  // Set header flags
  optional uint32 MH_NOUNDEFS = 99;
  optional uint32 MH_INCRLINK = 100;
  optional uint32 MH_DYLDLINK = 101;
  optional uint32 MH_BINDATLOAD = 102;
  optional uint32 MH_PREBOUND = 103;
  optional uint32 MH_SPLIT_SEGS = 104;
  optional uint32 MH_LAZY_INIT = 105;
  optional uint32 MH_TWOLEVEL = 106;
  optional uint32 MH_FORCE_FLAT = 107;
  optional uint32 MH_NOMULTIDEFS = 108;
  optional uint32 MH_NOFIXPREBINDING = 109;
  optional uint32 MH_PREBINDABLE = 110;
  optional uint32 MH_ALLMODSBOUND = 111;
  optional uint32 MH_SUBSECTIONS_VIA_SYMBOLS = 112;
  optional uint32 MH_CANONICAL = 113;
  optional uint32 MH_WEAK_DEFINES = 114;
  optional uint32 MH_BINDS_TO_WEAK = 115;
  optional uint32 MH_ALLOW_STACK_EXECUTION = 116;
  optional uint32 MH_ROOT_SAFE = 117;
  optional uint32 MH_SETUID_SAFE = 118;
  optional uint32 MH_NO_REEXPORTED_DYLIBS = 119;
  optional uint32 MH_PIE = 120;
  optional uint32 MH_DEAD_STRIPPABLE_DYLIB = 121;
  optional uint32 MH_HAS_TLV_DESCRIPTORS = 122;
  optional uint32 MH_NO_HEAP_EXECUTION = 123;
  optional uint32 MH_APP_EXTENSION_SAFE = 124;

  // Set segment flags masks
  optional uint32 SG_HIGHVM = 125;
  optional uint32 SG_FVMLIB = 126;
  optional uint32 SG_NORELOC = 127;
  optional uint32 SG_PROTECTED_VERSION_1 = 128;

  // Set sections flags masks
  optional uint32 SECTION_TYPE = 129;
  optional uint32 SECTION_ATTRIBUTES = 130;

  // Set section types
  optional uint32 S_REGULAR = 131;
  optional uint32 S_ZEROFILL = 132;
  optional uint32 S_CSTRING_LITERALS = 133;
  optional uint32 S_4BYTE_LITERALS = 134;
  optional uint32 S_8BYTE_LITERALS = 135;
  optional uint32 S_NON_LAZY_SYMBOL_POINTERS = 136;
  optional uint32 S_LAZY_SYMBOL_POINTERS = 137;
  optional uint32 S_LITERAL_POINTERS = 138;
  optional uint32 S_SYMBOL_STUBS = 139;
  optional uint32 S_MOD_INIT_FUNC_POINTERS = 140;
  optional uint32 S_MOD_TERM_FUNC_POINTERS = 141;
  optional uint32 S_COALESCED = 142;
  optional uint32 S_GB_ZEROFILL = 143;
  optional uint32 S_INTERPOSING = 144;
  optional uint32 S_16BYTE_LITERALS = 145;
  optional uint32 S_DTRACE_DOF = 146;
  optional uint32 S_LAZY_DYLIB_SYMBOL_POINTERS = 147;
  optional uint32 S_THREAD_LOCAL_REGULAR = 148;
  optional uint32 S_THREAD_LOCAL_ZEROFILL = 149;
  optional uint32 S_THREAD_LOCAL_VARIABLES = 150;
  optional uint32 S_THREAD_LOCAL_VARIABLE_POINTERS = 151;
  optional uint32 S_THREAD_LOCAL_INIT_FUNCTION_POINTERS = 152;

  // Set section attributes
  optional uint32 S_ATTR_PURE_INSTRUCTIONS = 153;
  optional uint32 S_ATTR_NO_TOC = 154;
  optional uint32 S_ATTR_STRIP_STATIC_SYMS = 155;
  optional uint32 S_ATTR_NO_DEAD_STRIP = 156;
  optional uint32 S_ATTR_LIVE_SUPPORT = 157;
  optional uint32 S_ATTR_SELF_MODIFYING_CODE = 158;
  optional uint32 S_ATTR_DEBUG = 159;
  optional uint32 S_ATTR_SOME_INSTRUCTIONS = 160;
  optional uint32 S_ATTR_EXT_RELOC = 161;
  optional uint32 S_ATTR_LOC_RELOC = 162;
}
